# C++内存问题

不像Java,.Net能自动管理内存，C++要手动的管理内存问题问题。因为要注意的问题如下： 内存泄漏，野指针，访问越界。

### C++类的大小计算

[大小计算参考](https://blog.csdn.net/fengxinlinux/article/details/72836199)  
 1. 首先，类大小的计算遵循结构体的对其原则  
 2. 类的大小与成员变量有关，与成员函数和静态成员\(static\)无关。  
 3. 虚函数对类的大小有影响，是因为虚函数表指针带来的影响  
 4. 虚继承对类的大小有影响， 是因为虚基表指针带来的影响  
 5. 空类的大小是一个特殊情况，空类的大小为1

对其的目的是加快访问速度，节省空间在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。强制以多少字节对齐，\#pragma pack \(1\)  
计算就是，前面n个成员变量的空间大小一定是最大成员变量长度K\(比如double 为8\)的整数倍。n个成员变量之后的成员，能组合成K长度就组合，不然长度就是K。  
虚函数对类的大小有影响，无论多少个虚函数，只带来默认对其字节大小的空间，比如vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。因为虚函数在虚函数表中是连在一起的，因此只需要记录开始位置。  
对于指针而言，其大小都是4，类似于字节对齐。  
在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。  
使用未初始化的局部指针变量是件很危险的事，所以，在使用局部指针变量时，一定要及时将其初始化。

```cpp
int b = 3;
int *p = &b;
*p = 5;
```

### C++浮点数表示方法

![](/assets/Float_represent.png)  
于是，  
一个规格化的32位浮点数ｘ的真值为：  
$$x=(-1)^s(1.M)2^{E-127}$$  
一个规格化的64位浮点数ｘ的真值为：  
$$x=(-1)^s(1.M)2^{E-1023}$$

### 析构函数是虚函数

```cpp
Base* pTest = new Derived();
delete pTest;
```

如果基类Base的析构函数不是virtual函数，则上面代码delete时，衍生类Derived的析构函数不被调用，因此衍生类的资源不会释放。只有当Base类的析构函数是virtual的时候，上面的delete才能调用衍生类与基类的析构函数。  

####构造函数与析构函数的重载
构造函数可以重载：构造函数可以用多个，且可以带参数  
析构函数不可以重载：析构函数只可能有一个，且不能带参数，即没有参数，没有返回值，没有函数类型。  

#####Explict
加在类的构造函数之前，防止类对象之间被隐式转换  

####List&Vector
list将元素按顺序储存在链表中。与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。  
Vector:地址连续   
List:地址不连续  

