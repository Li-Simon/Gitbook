# 第二节 反射

Static private 的属性可以通过反射捕捉到。

**谈起反射，首先想到的是网上有位大神说过的例子：**[**两个现实中的例子**](https://blog.csdn.net/qiaoquan3/article/details/51423890)

1、B超：大家体检的时候大概都做过B超吧，B超可以透过肚皮探测到你内脏的生理情况。这是如何做到的呢？B超是B型超声波，它可以透过肚皮通过向你体内发射B型超声波，当超声波遇到内脏壁的时候就会产生一定的“回音”反射，然后把“回音”进行处理就可以显示出内脏的情况了（我不是医生也不是声学专家，不知说得是否准确^\_^）。  
2、地球内部结构：地球的内部结构大体可以分为三层：地壳、地幔和地核。地壳是固体，地核是液体，地幔则是半液半固的结构（中学地理的内容，大家还记得吧？）。如何在地球表面不用深入地球内部就知道其内部的构造呢？对，向地球发射“地震波”，“地震波”分两种一种是“横波”，另一种是“纵波”。“横波”只能穿透固体，而“纵波”既可穿透固体又可以穿透液体。通过在地面对纵波和横波的反回情况，我们就可以大体断定地球内部的构造了。

大家注意到这两个例子的共同特点，就是从一个对象的外部去了解对象内部的构造，而且都是利用了波的反射功能。在.NET中的反射也可以实现从对象的外部来了解对象（或程序集）内部结构的功能，哪怕你不知道这个对象（或程序集）是个什么东西，另外.NET中的反射还可以运态创建出对象并执行它其中的方法。

**反射是.NET中的重要机制，通过反射，可以在运行时获得程序或程序集中每一个类型（包括类、结构、委托、接口和枚举等）的成员和成员的信息。有了反射，即可对每一个类型了如指掌。另外我还可以直接创建对象，即使这个对象的类型在编译时还不知道。 **

**反射的作用（网上广泛流传的）：**

作用：1.可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型；  
2.应用程序需要在运行时从某个特定的程序集中载入一个特定的类型，以便实现某个任务时可以使用到反射；  
3.反射主要应用与类库，这些类需要知道一个类型的定义，以便提供更多的功能；

什么，不好理解？好吧，我根本背不起来！其实总计起来就是：

作用：反射可以获得程序或程序集的信息，也可以动态的加载程序集，并创建其中某个类型的实例，执行实例中的方法。

接下来我们实例来简单体会一下具体玩法。

**反射的用途：**  
    （1）使用Assembly定义和加载程序集，加载在程序集清单中列出模块，以及从此程序集中查找类型并创建该类型的实例。  
    （2）使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。  
    （3）使用ConstructorInfo了解构造函数的名称、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。  
    （4）使用MethodInfo了解方法的名称、返回类型、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。  
    （5）使用FiedInfo了解字段的名称、访问修饰符（如public或private）和实现详细信息（如static）等，并获取或设置字段值。  
    （6）使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。  
    （7）使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。  
    （8）使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。

**反射用到的命名空间：                          
**    System.Reflection  
    System.Type  
    System.Reflection.Assembly

**反射用到的主要类：**  
    System.Type 类－－通过这个类可以访问任何给定数据类型的信息。  
    System.Reflection.Assembly类－－它可以用于访问给定程序集的信息，或者把这个程序集加载到程序中。

**System.Type类：**  
    System.Type 类对于反射起着核心的作用。但它是一个抽象的基类，Type有与每种数据类型对应的派生类，我们使用这个派生类的对象的方法、字段、属性来查找有关该类型的所有信息。  
    获取给定类型的Type引用有3种常用方式：  
**●使用 C\# typeof 运算符。  
        Type t = typeof\(string\);  
    ●使用对象GetType\(\)方法。  
        string s = "grayworm";  
        Type t = s.GetType\(\);  
    ●还可以调用Type类的静态方法GetType\(\)。  
        Type t = Type.GetType\("System.String"\);                          
**  
    上面这三类代码都是获取string类型的Type，在取出string类型的Type引用t后，我们就可以通过t来探测string类型的结构了。  
string n = "grayworm";  
            Type t = n.GetType\(\);  
            foreach \(MemberInfo mi in t.GetMembers\(\)\)  
            {  
                Console.WriteLine\("{0}/t{1}",mi.MemberType,mi.Name\);  
            }

**Type类的属性：                          
**        Name 数据类型名  
        FullName 数据类型的完全限定名\(包括命名空间名\)  
        Namespace 定义数据类型的命名空间名  
        IsAbstract 指示该类型是否是抽象类型  
        IsArray   指示该类型是否是数组  
        IsClass   指示该类型是否是类  
        IsEnum   指示该类型是否是枚举  
        IsInterface    指示该类型是否是接口  
        IsPublic 指示该类型是否是公有的  
        IsSealed 指示该类型是否是密封类  
        IsValueType 指示该类型是否是值类型  
**Type类的方法：                          
**        GetConstructor\(\), GetConstructors\(\)：返回ConstructorInfo类型，用于取得该类的构造函数的信息  
        GetEvent\(\), GetEvents\(\)：返回EventInfo类型，用于取得该类的事件的信息  
        GetField\(\), GetFields\(\)：返回FieldInfo类型，用于取得该类的字段（成员变量）的信息  
        GetInterface\(\), GetInterfaces\(\)：返回InterfaceInfo类型，用于取得该类实现的接口的信息  
        GetMember\(\), GetMembers\(\)：返回MemberInfo类型，用于取得该类的所有成员的信息  
        GetMethod\(\), GetMethods\(\)：返回MethodInfo类型，用于取得该类的方法的信息  
        GetProperty\(\), GetProperties\(\)：返回PropertyInfo类型，用于取得该类的属性的信息  
    可以调用这些成员，其方式是调用Type的InvokeMember\(\)方法，或者调用MethodInfo, PropertyInfo和其他类的Invoke\(\)方法。

using System.Reflection;可以加在Assemblyinfo.cs中？

**反射在System.Type类的应用：**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;

namespace ReflectionTest
{
    class Contact
    {
        public string Name { get; private set; }
        public string Address { get; set; }

        public string m_sMail;
        private static  string m_sPhone =  "0739" ;
        private static List<String> ticketList = new List<String>()
        {
            "T1","T2","T3","T4","T5","T6","T7","T8","T9","T10",
            "T11","T12","T13","T14","T15","T16","T17","T18","T19","T20",
            "T21","T22","T23","T24","T25","T26","T27","T28","T29","T30",
            "T31","T32","T33","T34","T35","T36","T37","T38","T39","T40",
            "T41","T42","T43","T44","T45","T46","T47","T48","T49","T50"
        };
        public Contact()
        {
        }

        public Contact(string name, string addr)
        {
            Name = name;
            Address = addr;
        }

        public void Print()
        {
            Console.WriteLine("Name: " + Name + "\nAddress: " + Address);
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Contact pt = new Contact();
            Type t = pt.GetType();

            ConstructorInfo[] contInfo = t.GetConstructors();
            Console.WriteLine("1.Find the constructor in class:");
            Console.WriteLine("Number of constructors:" + contInfo.Length);
            int num = 0;
            foreach(ConstructorInfo c in contInfo)
            {
                ParameterInfo[] ps = c.GetParameters();
                Console.WriteLine("This is " + num++ + " constructor：");
                foreach (ParameterInfo pi in ps)
                {
                    Console.Write(pi.ParameterType.ToString()+" "+pi.Name + ", ");
                }
                Console.WriteLine();
            }

            FieldInfo fieldInfo2 = t.GetField("m_sPhone", BindingFlags.NonPublic | BindingFlags.Static);
            object value2 = fieldInfo2.GetValue(null);
            Console.WriteLine("\nPrivate parameter: " + value2.ToString());

            FieldInfo fieldInfo = t.GetField("ticketList", BindingFlags.NonPublic | BindingFlags.Static);
            object value = fieldInfo.GetValue(null);
            Console.WriteLine("\nPrivate parameter: "+value.ToString());
            foreach (String a in (value as List<String>))
            {
                Console.Write(a + " ");
            }
            Console.WriteLine();

            FieldInfo[] fldInfo = t.GetFields();
            Console.WriteLine();
            Console.WriteLine("2.FieldInfo in class:");
            foreach (FieldInfo c in fldInfo)
            {
                 Console.WriteLine(c.ToString());
            }

            MemberInfo[] membinfo = t.GetMembers();
            Console.WriteLine();
            Console.WriteLine("3.MemberInfo in class:");
            foreach (MemberInfo c in membinfo)
            {
                Console.WriteLine(c.ToString());
            }

            MethodInfo[] methinfo = t.GetMethods();
            Console.WriteLine();
            Console.WriteLine("4.MethodInfo in class:");
            foreach (MethodInfo c in methinfo)
            {
                Console.WriteLine(c.ToString());
            }

            PropertyInfo[] propinfo = t.GetProperties();
            Console.WriteLine();
            Console.WriteLine("5.PropertyInfo in class:");
            foreach (PropertyInfo c in propinfo)
            {
                Console.WriteLine(c.ToString());
            }

            Console.WriteLine("\n6. Using constructor create instance dynamic:");
            Type[] tt = new Type[2];
            tt[0] = typeof(string);
            tt[1] = typeof(string);

            ConstructorInfo ctInfo = t.GetConstructor(tt);
            object[] obj = new object[2] { "Simon Li", "Shanghai Pudong" };
            object o = ctInfo.Invoke(obj);
            ((Contact)o).Print();

            Console.WriteLine("\n7.Create instance with Activator:");
            Object[] objs = new object[2] { "Alpha Li", "ShenZheng" };
            object ob = Activator.CreateInstance(t, objs);
            ((Contact)ob).Print();

            Console.WriteLine("\n8:Using reflection get object, call properties, methods and fields:");
            object obNew = Activator.CreateInstance(t);
            FieldInfo fi7 = t.GetField("m_sMail");
            fi7.SetValue(obNew, "lipp09");
            PropertyInfo pi7 = t.GetProperty("Name");
            pi7.SetValue(obNew, "Simon Li");
            PropertyInfo pAddr7 = t.GetProperty("Address");
            pAddr7.SetValue(obNew, "Shanghai",null);
            MethodInfo mi7 = t.GetMethod("Print");
            mi7.Invoke(obNew, null);

            Console.WriteLine("\nI. Using reflection with assembly:");
            Assembly ass = Assembly.Load("ReflectionTest");
            Type tRef = ass.GetType("ReflectionTest.Contact");
            object oRef = Activator.CreateInstance(tRef, "Simon Li", "ShenZheng");
            MethodInfo mi = tRef.GetMethod("Print");
            mi.Invoke(oRef, null);

            Console.WriteLine("\nII.Get all types with full name of dll:");
            Assembly assembly = Assembly.Load("mscorlib.dll");
            Type[] aa = assembly.GetTypes();
            foreach(Type a in aa)
            {
                if(a.FullName == "System.String")
                {
                    Console.WriteLine(assembly.GetName());
                    Console.WriteLine("Get System.String type with reflection");
                }
            }
            Console.Read();
        }
    }
}
```



