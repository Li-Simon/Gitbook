# Windows C++
##进程间相互通讯（IPC）  
[参考C++线程同步的四种方式（Windows）](https://blog.csdn.net/s_lisheng/article/details/74278765)  
1. 管道：速度慢，容量有限，只有父子进程之间能通讯  
2. FIFO:任何进程间能通讯，但是速度慢  
3. 消息队列：容量收到限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题  
4. 信号量： 不能传递复杂消息，只用能来同步    
5. 共享内存区： 能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用于线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。  


##线程同步
为啥需要线程同步：多线程访问同一全局变量，如果都市读取操作，则会出现问题。因此在向变量写入数据时，禁止其他线程对其的任何访问，直到赋值过程结束后再解除对其他线程的访问限制。这种保证线程能了解其他线程任务处理结束后的处理结果而采取的保护措施即使线程同步。  
###线程同步
线程同步是指线程之间具有的一种制约关系，一个线程的执行依赖于另一个线程的消息，当它没有得到另一个线程的消息时应该等待，直到消息到达时才被唤醒。  
###线程互斥
县城互斥是指对于共享的操作系统资源（譬如全局变量就是一种共享资源），在各线程访问时的排他性。当有若干个线程毒药使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。  
从大的方面讲，线程的同步可分用户模式的线程同步和内核对象的线程同步两大类。

用户模式中线程的同步方法主要有原子访问和临界区等方法。其特点是同步速度特别快，适合于对线程运行速度有严格要求的场合。
内核对象的线程同步则主要由事件、等待定时器、信号量以及信号灯等内核对象构成。由于这种同步机制使用了内核对象，使用时必须将线程从用户模式切换到内核模式，而这种转换一般要耗费近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。
1. 事件（Event）
2. 信号量（semaphore）
3. 互斥量(mutex) 
4. 临界区(Critical Section)