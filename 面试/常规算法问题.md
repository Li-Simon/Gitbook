# 常规问题

### 数值的整数次方

$$\kern{4 em} a^n = a^{(n-1)/2}a^{(n-1)/2}$$,a is even  
$$\kern{4 em} a^n = a^{(n-1)/2}a^{(n-1)/2}a$$,a is old

```cpp
double Chapter3::Power(double base, int exponent)
{
    if(base <= 0)
    {
        this->bmInvideSetting = false;
        return 0;
    }
    if(exponent ==0)
    {
        return 1;
    }

    if(exponent < 0)
    {
        base = 1.0/base;
        exponent = -exponent;
    }
    double result = Power(base, exponent>>1);
    result *= result;
    if(exponent & 0x1 == 1)
        result *= base;
    return result;
}
```

### 数组奇偶分类

奇数在前，偶数在后排列，复杂度$$O(n)$$

```cpp
void Chapter3::RecordOddEven(int *pData, unsigned int length)
{
    if(pData == NULL || length == 0)
        return;
    int *pStart = pData;
    int *pEnd = pData + length - 1;
    int temp;
    while(pStart < pEnd)
    {
        if(*pStart & 1 == 1)
        {
            pStart++;
        }
        else
        {

            temp = *pEnd;
            *pEnd = *pStart;
            *pStart = temp;
            pEnd--;
        }
    }
}
```

pStart &lt; pEnd比大小，就是比较内存中位置先后。

### 一次查找链表倒数第k个节点

```cpp
ListNode* Chapter3::FindKthToTail(ListNode* pHeadList, unsigned int k)
{
    if(pHeadList == NULL)
        return NULL;
    ListNode *KthNode = pHeadList;
    int num = 0;

    while(++num<k)
    {
        pHeadList = pHeadList->m_pNext;
        if(pHeadList ==NULL)
            return NULL;
    }
    while(pHeadList != NULL)
    {
        pHeadList = pHeadList->m_pNext;
        if(pHeadList ==NULL)
            return KthNode;
        KthNode = KthNode->m_pNext;

    }
}
```

```cpp
//test FindKthToTail
int _tmain(int argc, _TCHAR* argv[])
{
    Chapter3* chp = new Chapter3();
    ListNode* p;
    ListNode* head = new ListNode();
    p = head;
    for(int n = 0; n < 10; n++)
    {
        ListNode* node = new ListNode();
        node->m_value = n;
        p->m_pNext = node;
        p = node;
    }
    p->m_pNext = NULL;
    int k_th = 2;
    ListNode *kthNode = chp->FindKthToTail(head, k_th);
    cout << "Last "<< k_th <<" is:"<<kthNode->m_value<<endl;
    return 0;
}
```

## 树

##### 二叉搜索树的后序遍历

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果，是返回true,否则返回false。假设输入的数组的任意两个数字都不相同。  
二叉搜索树的特征是结点的值大于所有左子树的值，且小于所有右子树的值。如果是后序遍历，则最后一个数是根节点的值，这个值通过一刀把它前面的数组切分成左右两部分，左部分的值都小于小于该值，为树的左子树，右边部分的值都大于该值，是右子树。如果这个划分不存在，则输入数组不是某二叉树的后序遍历。  
![](/assets/binary_search_tree.png)

```cpp
bool CTree::VerifySequenceOnBST(int sequence[], int length)
{
    if(sequence == NULL || length< 0)
        return false;

    int rootValue = sequence[length -1];
    int leftTreeLength = 0;
    for(int i = 0; i < length; i++)//finding the point can devide the sequence into 2 parts
    {
        if(sequence[i] > rootValue && leftTreeLength == 0)
        {
            leftTreeLength = i+1;
            break;
        }
    }
    //make sure the right part large than the root value
    for(int i = leftTreeLength; i < length; i++ )
    {
        if(sequence[i] < rootValue)
            return false;
    }

    bool left = true;
    bool right = true;
    if(leftTreeLength > 0)
        left = VerifySequenceOnBST(sequence, leftTreeLength);

    if(length - 1 - leftTreeLength > 0)
        left = VerifySequenceOnBST(sequence + leftTreeLength, length - leftTreeLength - 1);

    return (left&&right);
}
```

####二叉树中和为某一值的路径
输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的
所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。  


