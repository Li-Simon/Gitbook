# 线程与进程
问题：  
1. 为什么需要进程的同步或互斥？为什么需要进程间通信？  
进程互斥，同步的概念是并发进程下存在的概念，有了并发进程，就产生了资源的竞争与协作，从而就要通过进程的互斥，同步，通信来解决资源的竞争与协作问题[^1]。  
进程的互斥，同步，通信都市基于这两种基本关系而存在的，为了解决进程间竞争关系(间接制约关系)而引入进程互斥；为了解决进程间松散的协作关系(直接制约关系)而引入进程同步；为了解决进程间紧密的协作关系而引入进程通信。  
  
####第一种是竞争关系 

系统中的多个进程之间彼此无关，它们并不知道其他进程的存在，并且也不受其他进程执行的影响。例如，批处理系统中建立的多个用户进程， 分时系统中建立的多个终端进程。由于这些进程共用了一套计算机系统资源，因而， 必然要出现多个进程竞争资源的问题。当多个进程竞争共享硬设备、存储器、处理器 和文件等资源时，操作系统必须协调好进程对资源的争用。

资源竞争出现了两个控制问题：一个是死锁 （deadlock ）问题，一组进程如果都获得了部分资源，还想要得到其他进程所占有的资源，最终所有的进程将陷入死锁。另一个是饥饿（starvation ）问题，这是指这样一种情况：一个进程由于其他进程总是优先于它而被无限期拖延。

操作系统需要保证诸进程能互斥地访问临界资源，既要解决饥饿问题，又要解决死锁问题。 
    进程的互斥（mutual exclusion ）是解决进程间竞争关系( 间接制约关系) 的手段。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。

####第二种是协作关系          

某些进程为完成同一任务需要分工协作，由于合作的每一个进程都是独立地以不可预知的速度推进，这就需要相互协作的进程在某些协调点上协 调各自的工作。当合作进程中的一个到达协调点后，在尚未得到其伙伴进程发来的消息或信号之前应阻塞自己，直到其他合作进程发来协调信号或消息后方被唤醒并继续执行。这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。

进程间的协作可以是双方不知道对方名字的间接协作，例如，通过共享访问一个缓冲区进行松散式协作；也可以是双方知道对方名字，直接通过通信机制进行紧密协作。允许进程协同工作有利于共享信息、有利于加快计算速度、有利于实现模块化程序设计。

进程的同步（Synchronization）是解决进程间协作关系( 直接制约关系) 的手段。进程同步指两个以上进程基于某个条件来协调它们的活动。一个进程的执行依赖于另一
个协作进程的消息或信号，当一个进程没有得到来自于另一个进程的消息或信号时则需等待，直到消息或信号到达才被唤醒。

不难看出，进程互斥关系是一种特殊的进程同步关系，即逐次使用互斥共享资源，也是对进程使用资源次序上的一种协调。   

###进程通信
并发进程之间的交互必须满足两个基本要求：同步和通信。      
程间通信就是在不同进程之间传播或交换信息，那么不同进程之间存在着什么双方都可以访问的介质呢？进程的用户空间是互相独立的，一般而言是不能互相访问的，唯一的例外是共享内存区。但是，系统空间却是“公共场所”，所以内核显然可以提供这样的条件。除此以外，那就是双方都可以访问的外设了。在这个意义上，两个进程当然也可以通过磁盘上的普通文件交换信息，或者通过“注册表”或其它数据库中的某些表项和记录交换信息。广义上这也是进程间通信的手段，但是一般都不把这算作“进程间通信”。因为那些通信手段的效率太低了，而人们对进程间通信的要求是要有一定的实时性。    
  进程间通信主要包括管道, 系统IPC(包括消息队列,信号量,共享存储), SOCKET.   
  管道分为有名管道和无名管道，无名管道只能用于亲属进程之间的通信，而有名管道则可用于无亲属关系的进程之间。  
  消息队列用于运行于同一台机器上的进程间通信，与管道相似；    
 　共享内存通常由一个进程创建，其余进程对这块内存区进行读写。得到共享内存有两种方式：映射/dev/mem设备和内存映像文件。前一种方式不给系统带来额外的开销，但在现实中并不常用，因为它控制存取的是实际的物理内存；
     本质上，信号量是一个计数器，它用来记录对某个资源（如共享内存）的存取状况。一般说来，为了获得共享资源，进程需要执行下列操作：   
　　（1）测试控制该资源的信号量；   
　　（2）若此信号量的值为正，则允许进行使用该资源，进程将进号量减1；   
　　（3）若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于0，进程被唤醒，转入步骤(1)；     
　　（4）当进程不再使用一个信号量控制的资源时，信号量值加1，如果此时有进程正在睡眠等待此信号量，则唤醒此进程。   
    套接字通信并不为Linux所专有，在所有提供了TCP/IP协议栈的操作系统中几乎都提供了socket，而所有这样操作系统，对套接字的编程方法几乎是完全一样的.[^2]     
Linux 下常见的进程通信的方法有 ：pipe（管道），FIFO（命名管道），socket（套接字），SysVIPC 的 shm（共享内存）、msg queue（消息队列），mmap（文件映射）。     
Windows下，进程通信主要有以下几种：内存映射、管道、消息等，但是内存映射是最基础的，因为，其他的进程通信手段在内部都是考内存映射来完成的。    

##总结
(1)进程是系统分配资源的最小单位，线程是处理器调度的最小单位。    
(2)进程是下面可以有多个线程，是线程的容器。进程下的线程共享一些资源，比如所有exe与dll模块的代码与数据。     
(3) 进程间可以通过事件，信号量，互斥量，临界区来实现同步，跨机器可以通过socket来进行同步。socket主要通过IP来绑定机器，通过端口来绑定该机器中的进程，另外一个就是通信协议。通过进程间通信可以是实现跨进程，跨机器的单例。    
(4)[同步与异步，阻塞与非阻塞](https://www.zhihu.com/question/19732473/answer/20851256
)： 
同步和异步关注的是消息通信机制：所谓同步就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用者返回，就得到了返回值。就是调用者主动等待调用这个结果。  
异步则相反：调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立即得到结果。而是在调用发出后，被调用者通过状态，通知来通知调用者，或者通过回调函数处理这个调用。  
举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。
 
阻塞和非阻塞关注的是程序在等待调用结果 （消息，返回值）时的状态：  
阻塞调用是在调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回。非阻塞调用指在不能立即得到结果之前，该调用不会阻塞档当前线程。  
还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。  
(5) 在Windwos中，进程同步主要有以下几种：临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphore）、事件（Event）。   
在Windows下，进程通信主要有以下几种：内存映射、管道、消息等，但是内存映射是最基础的，因为，其他的进程通信手段在内部都是靠内存映射来完成的。
##概念    
本节要讨论的概念

1. 进程，线程 
2. 内核对象 
3. 单线程多线程 
4. 同步与异步的概念 
5. 线程同步\(要明白这方实现方法的内核原理\)
   1. 关键段
   2. 读/写锁
   3. 条件变量
   4. 信号量
   5. 互斥量
   6. 事件
6. 线程池
7. 分布式系统中的线程，进程同步 
8. 内存管理

实际上按照《操作系统精髓与设计原理》来划分更为合理,但是难度大很多，还是弄懂一些基本概念就可以了。

1. 内核对象
2. 进程
3. 线程
4. 并发性：互斥与同步
5. 并发：饥饿与死锁
6. 内存管理与虚拟内存
7. 调度
   1. 单处理器
   2. 多处理器

## 内核对象

### 什么是内核对象

windows中，诸如：时间，管道，互斥量，完成端口，进程，线程都是内核对象。这些内核对象虽然通过不同的系统API来创建，但是这些API有一个共同的特点就是，需要传入SECURITY\_ATTRIBUTES安全描述符结构体指针，并且返回句柄\(HANDLE\)。根据这个特点，可以依据创建它的函数是否允许传入SECURITY\_ATTRIBUTES安全描述符。穿件内核对象之后，会返回一个值，也就是一个句柄Handle,可以通过这个句柄来操作这个内核对象。  
内核对象为一个数据结构且只能为内核访问，因此应用程序无法在内存中找到这些数据结构并直接改变他们的内容，Micsoft规定了这个限制是为了确保内核对象结构保持状态的一致。所以Microsoft能自由的添加，删除和修改这些结构中的成员，同时不干扰任何程序正常运行。

## 进程与线程

1、进程是系统分配资源的最小单位。  
2、线程是处理器调度的最小单位。  
3、一个进程可以包含很多线程，且这些线程共享进程内的所有资源。  
资源是什么？  
然后又有大致三种线程模型：进程模型、用户级线程、内核级线程，三种模型如图所示

![](/assets/thread_process.png)

|  | 进程 | 线程 |
| :--- | :--- | :--- |
| 组成 | 1. 一个内核对象，操作系统用它来管理进程。内核对象也是系统保存进程统计信息的地方。                                         2. 一个地址空间，其中包含所有可执行文件exe或dll模块的代码和数据。此外，它还包含动态内存分配，比如线程堆栈和堆的分配。 | 1. 线程的内核对象，操作系统用它来管理线程。系统还用内核对象来存放线程统计信息的地方。                                  2.  一个线程栈，用于维护线程执行时所需要的的所有函数参数和局部变量。 |
| 空间大小 | 32位系统最大4GB | Linux线程栈默认8Mb，在进行的堆李曼分配线程栈 |

### 进程

进程是一个正在运行的程序的一个实例，它由以下两个方面组成：  
1. 一个内核对象，操作系统用它来管理进程。内核对象也是系统保存进程统计信息的地方。  
2. 一个地址空间，其中包含所有可执行文件exe或dll模块的代码和数据。此外，它还包含动态内存分配，比如线程堆栈和堆的分配。  
进程需要记哪些系统发生的信息？  
进程要做任何事情，都必须让一个线程在它的上下文中运行，该线程负责执行进程地址空间包含的代码。  
对32位系统，每个进程最大$$2^{32}=$$4G内存空间，但是是虚拟内存空间。系统分前半部分（2G）作为进程私有空间；后半部分（2G）作为公用空间，用来存放内核代码、驱动代码、IO缓存区。  
一个进程可以有多个线程，所有线程都在进程的地址空间中"同时"执行代码。为此，每个线程都有它自己的一组CPU寄存器和它自己的堆栈。每个进程至少有一个线程来执行进程地址空间中包含的代码。当系统创建一个进程时，会自动的创建第一个线程，就是主线程。然后这个线程可以创建更多的线程，后者再创更多的线程。如果没有线程执行进程地址空间包含的代码，进程就失去了继续存在的理由，这时，系统会自动销毁进程及其地址空间。  
加载到进程地址空间的每一个可执行文件或者DLL文件都被赋予一个独一无二的实例。

#### 进程间通讯

进程间通讯的四种方式：剪贴板、匿名管道、命名管道和邮槽

### 线程

线程是进程的不同执行序列，也就是说线程是独立运行的基本单元，也是CPU调度的基本单位。  
线程有时候称为轻量级进程，是CPU使用的基本单元；它由线程ID，程序计数器，寄存器集合和堆栈组成。它与属于同一进程的其它线程共享代码段，数据段和其它操作系统资源\(如打开文件和信号\)  
在单个CPU计算机中，操作系统以轮询的方式为每个单独的线程分配时间量。  
线程的两个组成部分：  
1. 线程的内核对象，操作系统用它来管理线程。系统还用内核对象来存放线程统计信息的地方。  
2. 一个线程栈，用于维护线程执行时所需要的的所有函数参数和局部变量。  
![](/assets/cpu_thread.png)  
线程之间通讯：  
同一进程直接的线程：通过他们的公共地址空间交换信息，并访问进程中的共享资源。  
不同进程之间的线程：通过在两个不同进程间建立共享内存交换信息。

#### [线程的状态](https://blog.csdn.net/wolenski/article/details/7969908)

线程有四种状态：新生状态，可运行状态，被阻塞状态，死亡状态。状态之间的转换如下图所示：

![](/assets/thread_life_cycle.png)

### 堆，栈大小

栈：Linux软限制为8Mb，如果超过这个大小就出现segmentation fault。  
堆：默认没有软限制，只依赖于堆限制。  
那么，进程分配的空间是一个堆还是？  
堆：大家共有的空间。  
栈：是每个线程独有的。

## 线程同步

主要原理就是对进程中的公共资源进行保护，不让其它线程访问它。  
win32中四种主要的同步机制：  
\(1\)事件\(Event\)  
\(2\)信号量\(semaphore\)  
\(3\)互斥量\(mutex\)  
\(4\)临界区\(Critical section\)

### 内核对象被触发

进程内核对象在创建的时候总是处于未触发，当进程终止的时候，操作系统会自动使进程内核对象变成出发状态。  
触发的意思就是，外面的线程现在可以使用这些内核对象了。也就是等待该内核对象触发的线程变成可调度了。  
触发有什么比较形象的比喻吗？  

[^1]: 进程的同步与通信，进程与线程同步的区别，进程与线程通信的区别  https://www.cnblogs.com/youngforever/p/3250270.html  
[^2]:  进程/线程同步的方式和机制，进程间通信  https://www.cnblogs.com/memewry/archive/2012/08/22/2651696.html   


