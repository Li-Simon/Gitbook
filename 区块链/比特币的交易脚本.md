# 第三节 比特币的交易

输入脚本也称签名脚本，输出脚本也称赎回脚本  
在这里我们先讨论单输入单输出的比特币交易，因为这样描述起来更方便且不影响对『脚本』的理解。[^1]  
   [9c50cee8d50e273100987bb12ec46208cb04a1d5b68c9bea84fd4a04854b5eb1](https://blockchain.info/zh-cn/tx/9c50cee8d50e273100987bb12ec46208cb04a1d5b68c9bea84fd4a04854b5eb1)这是一个单输入单输出交易，看下我们要关注的数据：  
假设有如下一系列交易  
![](/assets/import4-3-10.png)  
在交易b中，Bob要转比特币给Carol,假设他用的就是Alice转给他的比特币。那么在交易b中，假设输入b脚本如下

> **Hash:**
>
> 9c50cee8d50e273100987bb12ec46208cb04a1d5b68c9bea84fd4a04854b5eb1
>
> **输入交易:**
>
> 前导输入的Hash:  
> 437b95ae15f87c7a8ab4f51db5d3c877b972ef92f26fbc6d3c4663d1bc750149
>
> 输入脚本 scriptSig\(公钥与签名\):  
> 3045022100efe12e2584bbd346bccfe67fd50a54191e4f45f945e3853658284358d9c062ad02200121e00b6297c0874650d00b786971f5b4601e32b3f81afa9f9f8108e93c752201  
> 038b29d4fbbd12619d45c84c83cb4330337ab1b1a3737250f29cec679d7551148a
>
> **输出交易\(交易a的输出脚本\):**
>
> 转账值:  
> 0.05010000 btc
>
> 输出脚本 scriptPubKey:  
> OP\_DUP OP\_HASH160 be10f0a78f5ac63e8746f7f2e62a5663eed05788 OP\_EQUALVERIFY OP\_CHECKSIG

转账值：转移比特币数量

输出脚本scriptPubKey：也就是Bob想用这笔UTXO时需要解锁的脚本，也就是需要Bob去求解的一个方程，这个方程操作如下，以交易b的输入脚本为输入 x，以交易a的输出脚本作为函数 f，最终看能否f\(x\)是否成立  
如下图所示[^3]：  
![](/assets/import4-3-0.png)  
1. OP\_DUP ：duplicate operator,复制操作，复制了交易b中PUSHDATA,  
2. OP\_HASH160:先SHA256再ripemd160得到160位哈希值  
3. OP\_EQUALVERIFY  检验是否相等  
4. OP\_CHECKSIG 签名

在[Bitcoin Wiki](http://www.8btc.com/bitcoin_scripts)中提到：

> 原先发送币的一方，控制脚本运行，以便比特币在下一个交易中使用。想花掉币的另一方必须把以前记录的运行为真的脚本，放到输入区。

换句话说，在一个交易中，『输出脚本』是数学题，『输入脚本』是题解，**但不是这道数学题的题解**。我开始看Wiki的时候，在这里遇到了一些障碍，没法理解『输入脚本』和『输出脚本』的联系。但是在考虑交易间的关系后，就明白了。

假设有这么一系列交易[^2]：  
![](/assets/import4-3-10.png)  
1. 上图的三个交易都是单输入单输出交易  
2. 每个『输入交易』『输出交易』中，都包含对应的『脚本』  
3.**交易a**，Alice转账给Bob；**交易b**，Bob转账给Carol；**交易c**，Carol转账给Dave  
4. 当前交易的『输入』都引用前一个交易的『输出』，如交易b的『输入』引用交易a的『输出』

按照之前的说法，**交易a**中的『输出脚本』就是Alice为Bob出的数学题。那么，Bob想要引用**交易a**『输出交易』的比特币，就要解开这道数学题。题解是在**交易b**的『输入脚本』里给出的！Bob解开了这道题，获得了奖金，然后在**交易b**中为Carol出一道数学题，等待Carol来解…

所以说，下图中相同颜色的『输出』和『输入』才是一对题和解：  
![](/assets/import4-3-11.png)

---

**脚本语言**  
[Bitcoin Wiki](http://www.8btc.com/bitcoin_scripts)给出的对脚本的解释:

> 比特币在交易中使用脚本系统，与FORTH\(一种编译语言\)一样，脚本是简单的、基于堆栈的、并且从左向右处理，它特意设计成非图灵完整，没有LOOP语句。

要理解比特币脚本，先要了解『堆栈』，这是一个后进先出\(Last In First Out \)的容器，脚本系统对数据的操作都是通过它完成的。比特币脚本系统中有两个堆栈：主堆栈和副堆栈，一般来说主要使用主堆栈。举几个简单的例子，看下指令是如何对堆栈操作的（完整的指令集在[Wiki](http://www.8btc.com/bitcoin_scripts)里可以找到）:

下面来看下这两段脚本是如何执行，来完成『解题』过程的。

1. 首先执行的是『输入脚本』。因为脚本是从左向右执行的，那么先入栈的是『签名』此签名是交易b中Bob的签名，，随后是『公钥』，Bob的公钥（能通过HASH160得到交易a中输出交易的地址）

![](/assets/import4-3-4.png)

2.接着，执行的是『输出脚本』交易a的输出脚本。从左向右执行，第一个指令是OP\_DUP——复制栈顶元素

![](/assets/import4-3-5.png)

3.OP\_HASH160——计算栈顶元素\(Bob公钥的\)Hash，得到pubkeyhash

![](/assets/import4-3-6.png)

4.将交易a『输出脚本』中的『公钥哈希』入栈，为了和前面计算得到的哈希区别，称它为pubkeyhash'

![](/assets/import4-3-7.png)

5.OP\_EQUALVERIFY——检查栈顶前两元素是否相等（判断地址交易a中转向的地址是否就是现在交易b中的输入脚本的地址），如果相等继续执行，否则中断执行，返回失败

![](/assets/import4-3-8.png)

6.OP\_CHECKSIG——使用栈顶前两元素执行签名校验操作（在地址正确的前提下，再校验Bob是否拥有该地址的私钥，也就是能否给出正确的签名），如果相等，返回成功，否则返回失败

![](/assets/import4-3-9.png)

这样一串指令执行下来，就可以验证这道数学题是否做对了，也就是说验明了想要花费『钱包地址』中比特币的人是否拥有对应的『私钥』。上面的执行过程是可以在[脚本模拟器](https://link.zhihu.com/?target=http%3A//webbtc.com/script)中执行的，能够看到每一步执行的状态，感兴趣的童鞋可以尝试一下。  
[模拟器](https://webbtc.com/script)

[^1]: 转自 汪海波Hyper的[理解比特币脚本](http://www.8btc.com/understand-bitcoin-script)

[^2]: Alice转给Bob比特币的数量是X，意味着Bob有X个UTXO\\(Unspent Transaction Output\\)，Bob可以用这UTXO转账给Carol,那为啥Bob就能用Alice转给他的那X个比特币呢？因为交易a的输出交易中，写明了Bob的地址以及转移的比特币数量。

[^3]: 转自Pony小马的[谈谈自己对比特币脚本的理解](https://blog.csdn.net/pony_maggie/article/details/73656597)

