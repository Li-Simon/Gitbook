# OOP

面向对象式语言的三大特征： 封装，继承，多态。  
面向对象编程\(OOP\)的八个基本概念：类与对象，封装，抽象，数据隐藏，多台，继承，动态绑定，消息传递。  
C++最重要的特征就是代码重用。这通过继承与组合来实现。

## 封装

封装时一种捆绑机制，能把函数和数据捆绑成类这种紧凑的形式。 封装的目的是实现数据的隐藏。  
数据和函数可以是私有的，也可以是公开的。私有的数据或函数只能在类里面访问，而公开的数据或代码则可以在类外访问。运用封装，可以把实现代码中的某些内容给隐藏起来。将函数代码与数据链接在一起，就可以生成对象，而这个对象则可以表示成某个以类为其类型的变量。

## 继承

继承的目的是实现代码的复用。在原理上是通过虚函数表。

### 三种继承方式

| 继承方式\成员属性 | public | protected | private |
| :--- | :--- | :--- | :--- |
| public继承 | public | protected | 子类无权访问 |
| protect继承 | protectd | protected | 子类无权访问 |
| private继承 | private | private | 子类无权访问 |

#### 二义性

C++可以多继承，但Java,C\#只能是单继承。正由于C++可以多继承，因此会导致二义性问题，也就是当一个类D继承自类B，类C，而类B，类C又共同的继承于类A。因为类B，类C分别拥有类A的一份拷贝，因此类D拥有类A的两份拷贝，因此类D在调用类A的接口时，编译器不知道需要调用哪一份拷贝，从而产生错误。通常有两个解决方法：  
1. 加上全局符确定调用哪一份拷贝，比如d.B::interface1\(\),调用属于类B的拷贝。  
2. 使用虚拟继承，使得多重继承类D只拥有类A的一份拷贝，也就是：

```cpp
class A {}
class B: virtual public A {};
class C: virtual public A {};
class D: public B, public C {}; 
int main()
{
    D d;
    A *pd = &d;//虚拟继承能转换成功，非虚拟继承不能
    return 0;
}
```

多重继承的优点是对象可以调用多个基类中的接口，缺点是容易出现继承上的二义性。

#### 虚拟继承

这里要讨论为啥虚拟继承能消除二义性。

```cpp
#include "StdAfx.h"
#include <iostream>
using namespace std;

class Parent
{
public:
    Parent():num(0){cout<<"Parent"<<endl;}
    Parent(int n):num(n){cout<<"Parent(int)"<<endl;}
private:
    int num;
};

class Child1 : virtual public Parent
{
public:
    Child1(){cout<<"Child1"<<endl;}
    Child1(int num):Parent(num){cout<<"Child1(int)"<<endl;}
};

class Child2 : virtual public Parent
{
public:
    Child2(){cout<<"Child2"<<endl;}
    Child2(int num):Parent(num){cout<<"Child2(int)"<<endl;}
};

class Dervied : public Child2,public Child1
{
public:
    Dervied():Child1(0),Child2(1){}
    Dervied(int num):Child1(num),Child2(num+1){}
};

void main()
{
    Dervied d(4);
}
```

多重继承类对象的构造顺序与其继承列表中基类的排列顺序一致\(在上面的例子中是class Dervied : public Child2,public Child1; 因此先调用Child2的构造函数再调用Child1的构造函数\)；而不是与构造函数初始化列表中的顺序一致\(Dervied\(int num\):Child1\(num\),Child2\(num+1\){}\)，因此结果输出如下：

![](/assets/multi_inhit.png)  
如果不是虚拟继承，则输出结果如下,它有两份Parent的拷贝：  
![](/assets/multi_inhit_nonvirtual.png)  

### 组合

集成与组合都是为了实现代码的复用。组合是通过把别的类作为自己的成员变量来使用其它类的功能。  
集成是is-a关系，组合是has-a关系。

## 多态

定义：允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。\(发送消息就是函数调用\)  
实现多态的技术称为:动态绑定，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。  
多态的作用：消除类型之间的耦合关系。  
子类覆盖父类的函数实现，也就是子类重新实现父类的函数。不同的子类对相同的父类函数可以有不同的实现，因此多态就是"一个接口，多种实现"。  
多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能确定。

### [多态原理与虚函数表](https://blog.csdn.net/dddd0216/article/details/79931607)

在实例化含有虚函数的类时，会在对象中产生一个指向虚函数表的指针\(大小为4字节\)，虚函数表中存放着虚函数实现的地址，每个虚函数均指向函数实现。  
1. 对于基类：虚函数指向基类的虚函数实现。  
2. 对于派生类：虚函数指向派生类的虚函数实现，若继承来的虚函数，派生类中没有实现，则指向基类的虚函数实现。  
3. 当派生类对象被视为基类对象时（派生类类型转成基类类型），虽然类型被转变，但虚函数表指针（地址）并没有发生改变，仍然是派生类的虚函数指针，所有在调用基类的函数时，会调用派生类的虚函数实现。

![](/assets/Virtual_function_table.png)
###抽象基类与纯虚函数

### 多态的好处

继承和多态本质的目的是为了代码重用和解耦。而重用和解耦是为了减少开发时间和减少错误。最终达到降低成本的目的。  
多态体现的就是“对扩展开放，对修改封闭”。封闭就是子类不能直接修改父类的其它函数，扩展开放也就是子类可以重写父类的函数。  
1. 可替换性\(substitutability\)。多态对已经存在代码具有可替换性。  
2. 可扩充性\(extensibility\)。多态对代码具有可扩充性，增加新的子类不影响已经存在类的多态性，继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现圆锥，半圆锥以及半球体的多态基础上，很容易增加球体类的多态性。  
3. 接口性\(interface-ability\)。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。  
4. 灵活性\(flexibility\)。它在应用中体现了灵活多样的操作，提高了使用效率。  
5.简化性\(simplicity\)。多态简化对应用软件的编写和修改过程，尤其在处理大量对象和操作时，这个特点尤为突出和重要。  
1. 提高了代码的维护性\(继承保证\)  
2. 提高了代码的扩展性\(由多态保证\)

![](/assets/OOP_basic_concept.png)

