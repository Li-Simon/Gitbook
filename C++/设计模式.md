# 设计模式

这里主要先介绍简单工厂，工厂方法与抽象工厂，对每种模式要讨论他们的优缺点。  
\(1\)简单工厂类：工厂类Factory负责创建所有的产品，通过switch结构来创建不同的产品\(ProductA,ProductB,ProductC...\)。但是每次新加产品必须修改工厂类Factory，在switch中添加新的case。因此，缺点是添加新产品后，整个工厂类必须重新编译。  
\(2\)工厂方法模式:为了克服简单工厂类在添加新产品必须重新编译所有产品的问题，工厂方法模式为每个产品新建一个工厂，即:工厂的职能是单一的，之生产特定的产品。所有的子工厂类继承于一个父工厂类，父工厂类的唯一接口是创建产品，在客户端来选择创建不同的工厂。

## 简单工厂

简单工厂类：工厂类Factory负责创建所有的产品，通过switch结构来创建不同的产品\(ProductA,ProductB,ProductC...\)。但是每次新加产品必须修改工厂类Factory，在switch中添加新的case。因此，缺点是添加新产品后，整个工厂类必须重新编译。

![](/assets/Simple_Factory.png)  
ProductA,ProductB和ProductC继承自虚拟类Product，Show方法是不同产品的自描述。Factory依赖于ProductA,ProductB,ProductC，Factory根据不同的条件创建不同的Product对象。  
没增加一个产品类，比如ProductD，则需要在enum PRODUCTTYPE中添加TypeD，并且在class Factory中创建产品函数的switch结构中新加一个case。  
需要修改的地方主要是Factory，这里的工厂类的作用是生产不同种类的产品Product。

```cpp
#include <iostream>
#include <vector>
using namespace std;

typedef enum ProductTypeTag{
        TypeA,
        TypeB,
        TypeC}PRODUCTTYPE;

// Here is the product classclass Product{public:
        virtual void Show() = 0;};

class ProductA : public Product{public:
        void Show()
        {
                cout<<"I'm ProductA"<<endl;
        }};

class ProductB : public Product{public:
        void Show()
        {
                cout<<"I'm ProductB"<<endl;
        }};

class ProductC : public Product{public:
        void Show()
        {
                cout<<"I'm ProductC"<<endl;
        }};

// Here is the Factory class
class Factory{public:
        Product* CreateProduct(PRODUCTTYPE type)
        {
                switch (type)
                {
                case TypeA:
                        return new ProductA();

                case TypeB:
                        return new ProductB();

                case TypeC:
                        return new ProductC();

                default:
                        return NULL;
                }
        }};

int main(int argc, char *argv[])
{
        // First, create a factory object
        Factory *ProductFactory = new Factory();
        Product *productObjA = ProductFactory->CreateProduct(TypeA);
        if (productObjA != NULL)
                productObjA->Show();

        Product *productObjB = ProductFactory->CreateProduct(TypeB);
        if (productObjB != NULL)
                productObjB->Show();

        Product *productObjC = ProductFactory->CreateProduct(TypeC);
        if (productObjC != NULL)
                productObjC->Show();

        delete ProductFactory;
        ProductFactory = NULL;

        delete productObjA;
        productObjA = NULL;

        delete productObjB;
        productObjB = NULL;       

        delete productObjC;
        productObjC = NULL;

        return 0;
}
```

## 工厂方法模式

由于简单工厂模式的局限性，比如：工厂现在能生产ProductA、ProductB和ProductC三种产品了，此时，需要增加生产ProductD产品；那么，首先是不是需要在产品枚举类型中添加新的产品类型标识，然后，修改Factory类中的switch结构代码。是的，这种对代码的修改，对原有代码的改动量较大，易产生编码上的错误（虽然很简单，如果工程大了，出错也是在所难免的！！！）。这种对代码的修改是最原始，最野蛮的修改，本质上不能称之为对代码的扩展。同时，由于对已经存在的函数进行了修改，那么以前进行过的测试，都将是无效的，所有的测试，都将需要重新进行，所有的代码都需要进行重新覆盖。这种，增加成本，不能提高效率的事情，在公司是绝对不允许的（除非昏庸的PM）。出于种种原因，简单工厂模式，在实际项目中使用的较少。那么该怎么办？怎么办呢？需要对原有代码影响降到最小，同时能对原有功能进行扩展。  
工厂方法模式是在简单工厂模式的基础上，对“工厂”添加了一个抽象层。将工厂共同的动作抽象出来，作为抽象类，而具体的行为由子类本身去实现，让子类去决定生产什么样的产品。

![](/assets/Factory_method.png)  
如图，FactoryA专心负责生产ProductA，FactoryB专心负责生产ProductB，FactoryA和FactoryB之间没有关系；如果到了后期，如果需要生产ProductC时，我们则可以创建一个FactoryC工厂类，该类专心负责生产ProductC类产品。由于FactoryA、FactoryB和FactoryC之间没有关系，当加入FactoryC加入时，对FactoryA和FactoryB的工作没有产生任何影响，那么对代码进行测试时，只需要单独对FactoryC和ProductC进行单元测试，而FactoryA和FactoryB则不用进行测试，则可省去大量无趣无味的测试工作。  
其特点是：每个工厂只生产单一的产品，不同工厂生产不同的产品，工厂间相互独立，新加的产品（或工厂）不会对原有的产品产生影响。  
工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。  
1.  在设计的初期，就考虑到产品在后期会进行扩展的情况下，可以使用工厂方法模式；  
2.  产品结构较复杂的情况下，可以使用工厂方法模式；由于使用设计模式是在详细设计时，就需要进行定夺的，所以，需要权衡多方面的因素，而不能为了使用设计模式而使用设计模式。

```cpp
#include <iostream>
using namespace std;

class Product{public:
        virtual void Show() = 0;};

class ProductA : public Product{public:
        void Show()
        {
                cout<< "I'm ProductA"<<endl;
        }};

class ProductB : public Product{public:
        void Show()
        {
                cout<< "I'm ProductB"<<endl;
        }};

class Factory{public:
        virtual Product *CreateProduct() = 0;};

class FactoryA : public Factory{public:
        Product *CreateProduct()
        {
                return new ProductA ();
        }};

class FactoryB : public Factory{public:
        Product *CreateProduct()
        {
                return new ProductB ();
        }};


int main(int argc , char *argv [])
{
        Factory *factoryA = new FactoryA ();
        Product *productA = factoryA->CreateProduct();
        productA->Show();

        Factory *factoryB = new FactoryB ();
        Product *productB = factoryB->CreateProduct();
        productB->Show();

        if (factoryA != NULL)
        {
                delete factoryA;
                factoryA = NULL;
        }

        if (productA != NULL)
        {
                delete productA;
                productA = NULL;
        }

        if (factoryB != NULL)
        {
                delete factoryB;
                factoryB = NULL;
        }

        if (productB != NULL)
        {
                delete productB;
                productB = NULL;
        }
        return 0;
}
```



