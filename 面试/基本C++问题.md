# 基本C++问题

### sizeof

定义一个空的类型，里面没有任何成员变量和成员函数，但是对该类型求sizeof，得到的结果是多少？  
答案：1；  
不是0的原因是，当我们声明该类型的实例时，它必须在内存中有一定的空间，否则无法使用这些实例，至少占多少内存，由编译器决定，在VS中，每个空类型的实例占1字节的空间。  
面试官：如果在该类型里面添加一个构造函数和析构函数，再对该类型求sizeof，得到的结果又是多少？  
应聘者：1。因为调用构造函数与析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，与类型的实例无关，编译器也不会因为这两个函数而在实例中添加额外的信息。  
面试官：那如果把析构函数标记为虚函数呢？  
应聘者：编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向该虚函数表的指针，在32位的机器上，一个指针占4字节，因此求sizeof是4,不是4+1,因为只是指向虚函数表的指针的大小，在64位机器上，一个指针占8字节，因此求sizeof是8.

#### 数组与指针的sizeof

sizeof对数组，得到整个数组所占空间的大小。  
sizeof对指针，得到指针本身所占空间的大小。  
数组的名字就是一个指针，该指针指向数组的第一个元素，我们可以用一个指针来访问数组。也就是数组名加元素下标来访问数组元素或者获取数组元素的值。

```cpp
int data1[] = {1,4,7,9,6};
cout<<sizeof(data1)<<endl;
cout<<"1st of data1:"<<*data1<<endl;
cout<<"2st of data1:"<<*(data1 + 1)<<endl;
cout<<"1st of data1:"<<*(data1+3)<<endl;

20
1st of data1:1
2st of data1:4
1st of data1:9
```

#### class与struct区别

C++中Class成员变量或者成员函数默认private,而struct成员变量默认为public.  
C\#中，class与struct的成员变量与成员函数都默认是private.

```cpp
#include <iostream>
#include <array>
int main ()
{
    std::array<int,5> myints;
    std::cout << "size of myints:" << myints.size() << std::endl;
    std::cout << "sizeof(myints):" << sizeof(myints) << std::endl;
    return 0;
}
size of myints: 5
sizeof(myints): 20
```

#### String 类

[string](http://rsljdkt.iteye.com/blog/774188)的构造、拷贝构造、析构、赋值、输出、比较、字符串加、长度、子串

## 数据结构

数据结构一直是技术面试的重点，大多数面试题都是围绕数组，字符串，链表，树，栈以及队列这几种常用的数据结构展开的，因此每一个面试者毒药熟练掌握着集中数据结构。  
数组和字符串是两种最基本的数据结构，他们用连续内存分别储存数据和字符。链表和树是面试中出现频率最高的数据结构，由于操作链表和树需要大量的指针，应聘者在解决相关问题的时候一定要留意代码的鲁棒性，否则容易出现程序崩溃的问题。栈是一个与递归密切相关的数据结构，同样队列也与广度优先遍历算法密切相关，深入理解这两种数据结构能帮助我们解决很多算法问题。

### 数组

它占用一块连续的内存空间并按照顺序存储数据，创建数据时，我们需要首先指定数组的容量大小，然后根据大小分配内存。即使我们只在数组中存储一个数字，也需要为所有的数据预先分配内存，因此数组的空间效率不是很好，经常会有空闲的区域没有得到充分利用。  
数组中的内存是连续的，因此我们可以根据下标在O\(1\)时间读/写任何元素，因此它的时间效率是很高的。我们可以根据数组时间效率高的优点来实现简单的哈希表，把数组的下标设为哈希表的键值（key）,数组中的数据设为哈希表的value。这样就可以在O\(1\)时间内实现查找，从而快速，高效地解决很多问题。  
针对数组空间效率不高的问题，人们有设计实现了多种动态数组，比如STL中的vector,为了避免浪费，我们首先为数组开辟较小的空间，然后往数组中添加数据，当数据的数目超过数字的容量时，我们再重新分配一个更大的空间（STL中vector每次扩容时，新的容量都是前一次的两倍），把之前的数据复制到新的数组中，再把之前的内存释放，这样就减小内存的浪费。每次扩容都需要大量的额外操作，因此尽量减小改变数组容量大小的次数。  
简单设计Vector：一开始，新建一个大小为N的数组（弄成数组是保证内存是连续的），当vector中的元素内存超出开始的数组内存大小时，就新建一个大小为2N的数值，把原来的数组copy到新的数组，再释放原来的内存。用这种节奏来创建更大的数组来容纳更多的vector。

#### 数组中重复的数字

长度为n的数组，所有数字范围都是\[0,n-1\],其中有些数字是重复的，怎么在O\(n\)时间内找到重复的数字？  
解：从第一个数开始，假设数组第一个数字是k，看它是否等于下标0，不等于，把第一个数k放到数组第k个元素处之前，看第k个数字是否等于k，是的话，就找出重复的了，否则把k放入数组第k个元素，再把原来第k个元素放到其数值对应的数组位置，以此类推，直到找到重复的数字。

#### 不能修改数组，查找重复的数

数组大小是n+1，每个元素的范围是\[0,n-1\]，折半查找，比如\[0,n-1\]之间，分别统计处于\[0,\(n-1\)/2\]与\(\(n-1\)/2,n\]之间的数字个数，看是否大于它的区间宽度，如果大于，则对该区域折半查找（查找是对整个数组），这个时间复杂度就是O\(nlogn\),空间复杂度是O\(1\)

#### 判断某个数是否在有序矩阵中

矩阵元素大小每行从左向右一直递增，从上往下一直递增。  
解：我们从右上角元素开始查找。若要找的数小于该矩阵元元素值，则往左比较M\[i,j-1\]；若要找的数大于该矩阵元元素值，则往下比较M\[i+1,j\]；

```cpp
bool CList::FindNumberInMatrix(int* matrix, int rows, int columns, int number)
{
	int row = 0;
	int col = columns -1;
	bool found = false;
	while(row < rows && col >= 0)
	{
		if(matrix[row*columns + col] == number)
			return true;
		if(matrix[row*columns + col] < number)
			row++;
		else
			col--;
	}
	return false;
}
```



