# 进程间通信\(IPC\)

这节主要讨论进程之间的通讯，实际上也是为了处理多线程之间的通讯服务的。不讨论单个进程之间的线程间的通讯是因为，单个进程之间可以通过共享该进程的全局变量来实现线程之间的通讯。因此，麻烦的是不同进程间的两个线程之间的通讯，也就是进程之间的通讯[^1]。  
参考[多线程与多进程的区别\(小结\)](https://blog.csdn.net/hairetz/article/details/4281931)

## Linux下进程通信的几种方式：

不同进程之间通信只能使用内核对象吗？  
1. 管道\(Pipe\)及有名管道\(Named pipe\):管道具有单向性，可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。管道所传送的是无格式字节流。  
2. 信号\(Signal\)：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction\(实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了sigal函数\)。  
3. 报文\(Message\)队列\(消息队列\):消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承受无格式字节流以及缓冲区大小受限等缺点。  
4. [共享内存](https://www.jianshu.com/p/c1015f5ffa74)[^1]： 使得多个进程可以访问同一内存空间，是最快的可用IPC形式。是正对其它通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步与互斥。为了在多进程间交换信息，内核专门留出一块内存块，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。  
5. 信号量\(semaphore\):主要作为进程间以及同意进程不同线程之间的同步手段。  
6. [套接口\(Socket\)](https://www.jianshu.com/p/c1015f5ffa74
)[^2]:更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是用Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。  
套接字是支持TCP/IP的网络通信的基本操作单元，可以看作是不同主机之间的进程进行双向通信的端点，简单的说就是通信双方的一种约定，用套接字中相关函数来完成通信过程。Socket的特性由3个属性确定，他们分别是：域，端口号，协议类型。  
每一个基于TCP/IP网络通讯的程序\(进程\)都被赋予了唯一的端口和端口号，因此可以通过端口号来找到应用程序。端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字。

### 计算机如何识别单例

同一计算机中同一进程，跨进程；以及跨计算机怎么识别单例。  
同一进程：同一进程中的线程因为共享资源\(exe或dll模块的代码和数据\),因此可以通过共享的资源老实现单例。  
同一计算机，不同进程：上面的单例模式失效，在两个应用程序中可以分别创建一个单例。因此必须通过IPC来实现跨进程的单例。比如创建一个单例的exe\(taskmanager, windows media player\)，就必须用到IPC，比如：信号量，共享内存，命名管道。  
不同计算机之间：此时必须通过Socket来实现不同计算机不同进程间的通讯来实现单例了。参数服务器。  
总结来说，实现跨进程，跨电脑的单例涉及到进程间的通信。

##### 比如[window进程单例实现](https://blog.csdn.net/yangyang031213/article/details/61624519)：

可以通过命名事件或者通过命名互斥量\(Mutex\)来实现。必须是命名的，不是命名的不可以实现跨进程的单例。  
一个问题是，系统怎么管理这些事件，互斥量等内核对象？他们怎么知道这些内核对象已经存在？  
[答案分析](https://blog.csdn.net/toilet22/article/details/7869831)：当我们创建一个内核对象的时候，比如当我们创建一个命名的Mutex时，系统首先会在同一内核对象命名空间查想看是否已经存在一个同名的内核对象。如果存在，则内核接着检查对象的类型，如果类型相同，系统会接着执行一次安全检查，验证调用者是否拥有对该对象的完全访问限制。如果答案是肯定的，系统就会在进程的句柄表中查找一个空白记录项，并将其初始化为指向现有的内核对象。如果对象的类型不匹配，或者调用者被拒绝访问，CreateMetux就会失败\(返回NULL\)。可以参照《Windows核心编程》P47。

```cpp
auto h = ::CreateEvent(NULL, FALSE, TRUE, _T("already running"));
auto err = GetLastError();
if (err == ERROR_ALREADY_EXISTS)
{
        MessageBox(NULL, _T("already exist"), _T("ERROR"), SW_NORMAL);
        return FALSE;
}

auto handle = ::CreateMutex(NULL, TRUE, _T("already_running"));
auto err = GetLastError();
if (err == ERROR_ALREADY_EXISTS)
{
        MessageBox(NULL,_T("already exist"),_T("ERROR"),SW_NORMAL);
        return FALSE;
}
if (handle)
{
        ::ReleaseMutex(handle);
}
```

#### [内核对象命名空间](http://www.cnblogs.com/fangyukuan/archive/2010/08/31/1813733.html)

所有这些对象都共享单个名空间。因此下面的用法是错的。

所以为了防止名字的冲突，建议创建一个GUID ，并将GUID的字符串表达式用作对象名。

```cpp
HANDLE hMutex = CreateMutex(NULL. FALSE, "JeffObj");
HANDLE hSem = CreateSemaphore(NULL, 1, 1, "JeffObj");
DWORD dwErrorCode = GetLastError();
```

### [多线程和多进程的对比](https://blog.csdn.net/lishenglong666/article/details/8557215)

| 对比维度 | 多进程 | 多线程 | 总结 |
| :--- | :--- | :--- | :--- |
| 数据共享，同步 | 数据共享复杂，需要IPC;数据是分开的，同步简单 | 因为共享进程数据，数据共享简单，但也由此导致同步复杂 | 各有优势 |
| 内存，CPU | 占用内存多，切换复杂，CPU利用率低 | 占用内存少，切换简单，CPU利用率高 | 线程占优 |
| 创建销毁，切换 | 创建销毁，切换复杂，速度慢 | 创建销毁，切换简单，速度很快 | 线程占优 |
| 编程，调试 | 编程简单，调试简单 | 编程简单，调试复杂 | 进程占优 |
| 可靠性 | 进程间不会相互影响 | 一个线程挂掉将导致整个进程挂掉 | 进程占优 |
| 分布式 | 适用于多核，多机分布式；如果一台机器不够，扩展到多台机器比较简单 | 适用于多核分布式 | 进程占优 |

# 线程同步与互斥

上面讨论了不同进程之间通讯的问题，现在讨论同一进程之间的多线程通信问题。由于同一进程之间个线程共享相同的资源，因此必须处理资源共享中的同步问题。  
1. 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖于另外一个线程的消息，当他没有得到另外一个线程的时候应该等待，直到消息到达时才被唤醒。  
2. 线程互斥是指对于共享的操作系统资源\(比如全局变量\)，在各线程访问时的排他性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。  
线程互斥是一种特殊的线程同步。实际上，互斥与同步对应线程间通信发生的两种情况。  
1. 当有多个线程访问共享资源而不使资源被破坏时。  
2. 当一个线程需要将某个任务已经完成的情况通知另外一个或多个线程时。

### [用户模式和内核模式](http://blog.jobbole.com/109200/)

线程同步分为用户模式的线程同步和内核对象的线程同步两大类。  
用户模式中线程的同步方法主要有**原子访问和临界区**等方法。其特点是同步速度特别快，适合于对线程运行速度要求要求的场合。  
内核对象的线程同步主要由**事件，等待定时器，信号量以及信号灯**等内核对象构成。由于这种同步机制使用了内核对象，使用时必须将线程从用户模式切换到内核模式，而这种切换一般需要消耗近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。

#### 事件

事件是一个内核对象，不同进程间可以通过命名事件来通信。

#### 信号量

和其他核心对象一样，信号量也可以通过名字跨进程访问，

#### 互斥量

互斥量是为协调共同对一个共享资源的单独访问而设计的。互斥量是内核对象，所以它比临界区更加耗费资源，但是它可以命名，因此可以被其它进程访问

#### 原子访问

当必须以原子操作方式来修改单个值时，互锁访问函数是相当有用的。所谓原子访问，是指线程在访问资源时能够确保所有其他线程都不在同一时间内访问相同的资源。  
InterlockedExchangeAdd保证对变量的访问具有”原子性”。互锁访问的控制速度非常快，调用一个互锁函数的CPU周期通常小于50，不需要进行用户方式与内核方式的切换（该切换通常需要运行1000个CPU周期）。  
互锁访问函数的缺点在于其只能对单一变量进行原子访问，如果要访问的资源比较复杂，仍要使用临界区或互斥。

#### 临界区

临界区是通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。

| 同步方式 | 方式 | 怎么跨进程 | 模式 |
| :--- | :--- | :--- | :--- |
| 临界区 |  | 不可以 | 用户 |
| 原子访问 |  |  | 用户 |
| 事件 | 匿名事件，命名事件 | 命名事件 | 内核 |
| 信号量 | 用于同步 | 命名 | 内核 |
| 互斥量 | 用于互斥 | 命名 | 内核 |
| 全局变量 | 同一进程下线程共享资源 | 不可以 | 用户 |



