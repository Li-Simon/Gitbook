# 线程与进程
##总结
(1)进程是系统分配资源的最小单位，线程是处理器调度的最小单位。 
(2)进程是下面可以有多个线程，是线程的容器。进程下的线程共享一些资源，比如所有exe与dll模块的代码与数据。  
(3) 进程间可以通过事件，信号量，互斥量，临界区来实现同步，跨机器可以通过socket来进行同步。socket主要通过IP来绑定机器，通过端口来绑定该机器中的进程，另外一个就是通信协议。通过进程间通信可以是实现跨进程，跨机器的单例。  
(4)[同步与异步，阻塞与非阻塞](https://www.zhihu.com/question/19732473/answer/20851256
)： 
同步和异步关注的是消息通信机制：所谓同步就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用者返回，就得到了返回值。就是调用者主动等待调用这个结果。  
异步则相反：调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立即得到结果。而是在调用发出后，被调用者通过状态，通知来通知调用者，或者通过回调函数处理这个调用。  
举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。
 
阻塞和非阻塞关注的是程序在等待调用结果 （消息，返回值）时的状态：  
阻塞调用是在调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回。非阻塞调用指在不能立即得到结果之前，该调用不会阻塞档当前线程。  
还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。  
##概念    
本节要讨论的概念

1. 进程，线程 
2. 内核对象 
3. 单线程多线程 
4. 同步与异步的概念 
5. 线程同步\(要明白这方实现方法的内核原理\)
   1. 关键段
   2. 读/写锁
   3. 条件变量
   4. 信号量
   5. 互斥量
   6. 事件
6. 线程池
7. 分布式系统中的线程，进程同步 
8. 内存管理

实际上按照《操作系统精髓与设计原理》来划分更为合理,但是难度大很多，还是弄懂一些基本概念就可以了。

1. 内核对象
2. 进程
3. 线程
4. 并发性：互斥与同步
5. 并发：饥饿与死锁
6. 内存管理与虚拟内存
7. 调度
   1. 单处理器
   2. 多处理器

## 内核对象

### 什么是内核对象

windows中，诸如：时间，管道，互斥量，完成端口，进程，线程都是内核对象。这些内核对象虽然通过不同的系统API来创建，但是这些API有一个共同的特点就是，需要传入SECURITY\_ATTRIBUTES安全描述符结构体指针，并且返回句柄\(HANDLE\)。根据这个特点，可以依据创建它的函数是否允许传入SECURITY\_ATTRIBUTES安全描述符。穿件内核对象之后，会返回一个值，也就是一个句柄Handle,可以通过这个句柄来操作这个内核对象。  
内核对象为一个数据结构且只能为内核访问，因此应用程序无法在内存中找到这些数据结构并直接改变他们的内容，Micsoft规定了这个限制是为了确保内核对象结构保持状态的一致。所以Microsoft能自由的添加，删除和修改这些结构中的成员，同时不干扰任何程序正常运行。

## 进程与线程

1、进程是系统分配资源的最小单位。  
2、线程是处理器调度的最小单位。  
3、一个进程可以包含很多线程，且这些线程共享进程内的所有资源。  
资源是什么？  
然后又有大致三种线程模型：进程模型、用户级线程、内核级线程，三种模型如图所示

![](/assets/thread_process.png)

|  | 进程 | 线程 |
| :--- | :--- | :--- |
| 组成 | 1. 一个内核对象，操作系统用它来管理进程。内核对象也是系统保存进程统计信息的地方。                                         2. 一个地址空间，其中包含所有可执行文件exe或dll模块的代码和数据。此外，它还包含动态内存分配，比如线程堆栈和堆的分配。 | 1. 线程的内核对象，操作系统用它来管理线程。系统还用内核对象来存放线程统计信息的地方。                                  2.  一个线程栈，用于维护线程执行时所需要的的所有函数参数和局部变量。 |
| 空间大小 | 32位系统最大4GB | Linux线程栈默认8Mb，在进行的堆李曼分配线程栈 |

### 进程

进程是一个正在运行的程序的一个实例，它由以下两个方面组成：  
1. 一个内核对象，操作系统用它来管理进程。内核对象也是系统保存进程统计信息的地方。  
2. 一个地址空间，其中包含所有可执行文件exe或dll模块的代码和数据。此外，它还包含动态内存分配，比如线程堆栈和堆的分配。  
进程需要记哪些系统发生的信息？  
进程要做任何事情，都必须让一个线程在它的上下文中运行，该线程负责执行进程地址空间包含的代码。  
对32位系统，每个进程最大$$2^{32}=$$4G内存空间，但是是虚拟内存空间。系统分前半部分（2G）作为进程私有空间；后半部分（2G）作为公用空间，用来存放内核代码、驱动代码、IO缓存区。  
一个进程可以有多个线程，所有线程都在进程的地址空间中"同时"执行代码。为此，每个线程都有它自己的一组CPU寄存器和它自己的堆栈。每个进程至少有一个线程来执行进程地址空间中包含的代码。当系统创建一个进程时，会自动的创建第一个线程，就是主线程。然后这个线程可以创建更多的线程，后者再创更多的线程。如果没有线程执行进程地址空间包含的代码，进程就失去了继续存在的理由，这时，系统会自动销毁进程及其地址空间。  
加载到进程地址空间的每一个可执行文件或者DLL文件都被赋予一个独一无二的实例。

#### 进程间通讯

进程间通讯的四种方式：剪贴板、匿名管道、命名管道和邮槽

### 线程

线程是进程的不同执行序列，也就是说线程是独立运行的基本单元，也是CPU调度的基本单位。  
线程有时候称为轻量级进程，是CPU使用的基本单元；它由线程ID，程序计数器，寄存器集合和堆栈组成。它与属于同一进程的其它线程共享代码段，数据段和其它操作系统资源\(如打开文件和信号\)  
在单个CPU计算机中，操作系统以轮询的方式为每个单独的线程分配时间量。  
线程的两个组成部分：  
1. 线程的内核对象，操作系统用它来管理线程。系统还用内核对象来存放线程统计信息的地方。  
2. 一个线程栈，用于维护线程执行时所需要的的所有函数参数和局部变量。  
![](/assets/cpu_thread.png)  
线程之间通讯：  
同一进程直接的线程：通过他们的公共地址空间交换信息，并访问进程中的共享资源。  
不同进程之间的线程：通过在两个不同进程间建立共享内存交换信息。

#### [线程的状态](https://blog.csdn.net/wolenski/article/details/7969908)

线程有四种状态：新生状态，可运行状态，被阻塞状态，死亡状态。状态之间的转换如下图所示：

![](/assets/thread_life_cycle.png)

### 堆，栈大小

栈：Linux软限制为8Mb，如果超过这个大小就出现segmentation fault。  
堆：默认没有软限制，只依赖于堆限制。  
那么，进程分配的空间是一个堆还是？  
堆：大家共有的空间。  
栈：是每个线程独有的。

## 线程同步

主要原理就是对进程中的公共资源进行保护，不让其它线程访问它。  
win32中四种主要的同步机制：  
\(1\)事件\(Event\)  
\(2\)信号量\(semaphore\)  
\(3\)互斥量\(mutex\)  
\(4\)临界区\(Critical section\)

### 内核对象被触发

进程内核对象在创建的时候总是处于未触发，当进程终止的时候，操作系统会自动使进程内核对象变成出发状态。  
触发的意思就是，外面的线程现在可以使用这些内核对象了。也就是等待该内核对象触发的线程变成可调度了。  
触发有什么比较形象的比喻吗？

