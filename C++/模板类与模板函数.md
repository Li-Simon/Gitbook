# 模板类与模板函数

[Why can templates only be implemented in the header file?](https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file\)

Clarification: header files are not the \_only \_portable solution. But they are the most convenient portable solution

Error	LNK2019	unresolved external symbol "public: int \_\_thiscall Algo&lt;int&gt;::LongestIncreaseSubsequence\(int \* const,int\)" \(?LongestIncreaseSubsequence@?$Algo@H@@QAEHQAHH@Z\) referenced in function \_main	Algo	C:\Data\ShareFolder\Group\Tim\Code\Algo\Algo\Main.obj	1	

当模板声明在头文件，实现在cpp中，一般会出现上面的问题，原因是Algo&lt;int&gt; Alg实例化的时候，编译器会去创建一个int型的Algo的新类，以及LongestIncreaseSubsequence\(T arr\[\], int arrSize\)方法，因此编译器会去找这个方法的实现，如果没有找到，自然会报错。因此有如下两个方法

1. 在头文件中实现
2. 在头文件中声明，再在cpp中显示实例化\(explicit instantiations\) template class Algo&lt;int&gt;;并实现模板函数



方式1：实现在头文件里

```cpp
#pragma once
#include <algorithm>
using namespace std;

template<class T>
class Algo
{
public:
    Algo() {};
    ~Algo() {};
public:
    int LongestIncreaseSubsequence(T arr[], int arrSize)
    {
        int *maxLen = new int[arrSize]();
        for (int i = 0; i < arrSize; i++)
        {
            maxLen[i] = 1;
        }
        for (int j = 1; j < arrSize; j++)
        {
            int maxLenJ = 1;
            for (int i = 0; i < j; i++)
            {
                if (arr[i] < arr[j])
                {
                    maxLenJ = maxLen[i] + 1;
                    maxLen[j] = std::max({ maxLen[j] ,maxLenJ });
                }
            }
        }
        return maxLen[arrSize - 1];
    }
};
```

```cpp
//调用函数
#include "stdafx.h"
#include "Algo.h"
#include <iostream>
using namespace std;

int main()
{
    int param[6] = {5,3,4,8,6,7};
    int arrSize = sizeof(param) / sizeof(int);
    Algo<int> Alg;
    int maxLength = Alg.LongestIncreaseSubsequence(param, arrSize);
    cout << "Max length: " << maxLength << endl;
    return 0;
}
```

方式二：在头文件中声明，CPP中定义并对每种实例进行声明

```cpp
Algo.h
#pragma once
#include <algorithm>
using namespace std;


template<class T>
class Algo
{
public:
    Algo() {};
    ~Algo() {};
public:
    int LongestIncreaseSubsequence(T arr[], int arrSize);
}
```

```cpp
// Algo.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Algo.h"
#include <algorithm>
using namespace std;

template class Algo<int>; //必须先声明，才可以用
template class Algo<double>;
template class Algo<char>;
template<class T>
int Algo<T>::LongestIncreaseSubsequence(T arr[], int arrSize)
{
    int *maxLen = new int[arrSize]();
    for (int i = 0; i < arrSize; i++)
    {
        maxLen[i] = 1;
    }
    for (int j = 1; j < arrSize; j++)
    {
        int maxLenJ = 1;
        for (int i = 0; i < j; i++)
        {
            if (arr[i] < arr[j])
            {
                maxLenJ = maxLen[i] + 1;
                maxLen[j] = std::max({ maxLen[j] ,maxLenJ });
            }
        }
    }
    return maxLen[arrSize - 1];
}
```



