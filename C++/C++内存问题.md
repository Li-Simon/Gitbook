# C++内存问题

不像Java,.Net能自动管理内存，C++要手动的管理内存问题问题。因为要注意的问题如下： 内存泄漏，野指针，访问越界。
###C++内存分配方式[^1]
　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。   
　　栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。  
　　堆：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。   
　　自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
　　全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。  
　　常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。   
###堆栈的区别  
主要的区别由以下几点：
　　(1). 管理方式不同
　　(2). 空间大小不同
　　(3). 能否产生碎片不同
　　(4). 生长方向不同
　　(5). 分配方式不同
　　(6). 分配效率不同
　　管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
　　空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：
　　打开工程，依次操作菜单如下：Project->Setting->Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。
　　注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。
　　碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。
　　生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
　　分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
　　分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。
　　从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。
　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。
　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：） 
### C++类的大小计算

[大小计算参考](https://blog.csdn.net/fengxinlinux/article/details/72836199)  
 1. 首先，类大小的计算遵循结构体的对其原则  
 2. 类的大小与成员变量有关，与成员函数和静态成员\(static\)无关。  
 3. 虚函数对类的大小有影响，是因为虚函数表指针带来的影响  
 4. 虚继承对类的大小有影响， 是因为虚基表指针带来的影响  
 5. 空类的大小是一个特殊情况，空类的大小为1

对其的目的是加快访问速度，节省空间在vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。强制以多少字节对齐，\#pragma pack \(1\)  
计算就是，前面n个成员变量的空间大小一定是最大成员变量长度K\(比如double 为8\)的整数倍。n个成员变量之后的成员，能组合成K长度就组合，不然长度就是K。  
虚函数对类的大小有影响，无论多少个虚函数，只带来默认对其字节大小的空间，比如vc中默认是4字节对齐的，GNU gcc 也是默认4字节对齐。因为虚函数在虚函数表中是连在一起的，因此只需要记录开始位置。  
对于指针而言，其大小都是4，类似于字节对齐。  
在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。  
使用未初始化的局部指针变量是件很危险的事，所以，在使用局部指针变量时，一定要及时将其初始化。

```cpp
int b = 3;
int *p = &b;
*p = 5;
```

### C++浮点数表示方法

![](/assets/Float_represent.png)  
于是，  
一个规格化的32位浮点数ｘ的真值为：  
$$x=(-1)^s\times(1.M)\times2^{E-127}$$  
一个规格化的64位浮点数ｘ的真值为：  
$$x=(-1)^s\times(1.M)\times2^{E-1023}$$

### 析构函数是虚函数

```cpp
Base* pTest = new Derived();
delete pTest;
```

如果基类Base的析构函数不是virtual函数，则上面代码delete时，衍生类Derived的析构函数不被调用，因此衍生类的资源不会释放。只有当Base类的析构函数是virtual的时候，上面的delete才能调用衍生类与基类的析构函数。  

####构造函数与析构函数的重载
构造函数可以重载：构造函数可以用多个，且可以带参数  
析构函数不可以重载：析构函数只可能有一个，且不能带参数，即没有参数，没有返回值，没有函数类型。  

#####Explict
加在类的构造函数之前，防止类对象之间被隐式转换  

####List&Vector
list将元素按顺序储存在链表中。与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。  
Vector:地址连续   
List:地址不连续  

[^1]: C/C++内存管理详解  https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/