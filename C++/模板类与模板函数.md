# 模板类与模板函数

[Why can templates only be implemented in the header file?](https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file\)

模板的实现必须在头文件里面实现，

方式1：实现在头文件里

```cpp
#pragma once
#include <algorithm>
using namespace std;

template<class T>
class Algo
{
public:
	Algo() {};
	~Algo() {};
public:
	int LongestIncreaseSubsequence(T arr[], int arrSize)
	{
		int *maxLen = new int[arrSize]();
		for (int i = 0; i < arrSize; i++)
		{
			maxLen[i] = 1;
		}
		for (int j = 1; j < arrSize; j++)
		{
			int maxLenJ = 1;
			for (int i = 0; i < j; i++)
			{
				if (arr[i] < arr[j])
				{
					maxLenJ = maxLen[i] + 1;
					maxLen[j] = std::max({ maxLen[j] ,maxLenJ });
				}
			}
		}
		return maxLen[arrSize - 1];
	}
};
```

```cpp
Algo.h
#pragma once
#include <algorithm>
using namespace std;


template<class T>
class Algo
{
public:
    Algo() {};
    ~Algo() {};
public:
    int LongestIncreaseSubsequence(T arr[], int arrSize);
}
```

```cpp
// Algo.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Algo.h"
#include <algorithm>
using namespace std;

template class Algo<int>; //必须先声明，才可以用
template class Algo<double>;
template class Algo<char>;
template<class T>
int Algo<T>::LongestIncreaseSubsequence(T arr[], int arrSize)
{
    int *maxLen = new int[arrSize]();
    for (int i = 0; i < arrSize; i++)
    {
        maxLen[i] = 1;
    }
    for (int j = 1; j < arrSize; j++)
    {
        int maxLenJ = 1;
        for (int i = 0; i < j; i++)
        {
            if (arr[i] < arr[j])
            {
                maxLenJ = maxLen[i] + 1;
                maxLen[j] = std::max({ maxLen[j] ,maxLenJ });
            }
        }
    }
    return maxLen[arrSize - 1];
}
```

```
//调用函数
#include "stdafx.h"
#include "Algo.h"
#include <iostream>
using namespace std;

int main()
{
	int param[6] = {5,3,4,8,6,7};
	int arrSize = sizeof(param) / sizeof(int);
	Algo<int> Alg;
	int maxLength = Alg.LongestIncreaseSubsequence(param, arrSize);
	cout << "Max length: " << maxLength << endl;
	return 0;
}
```



